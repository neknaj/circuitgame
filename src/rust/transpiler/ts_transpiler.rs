use crate::vm::types::*;

pub fn transpile(module: Module,header: bool) -> Result<String,String> {
    if module.gates_symmetry.len()>0 {
        return Err(format!("TS transpiler does not support symmetry module: {}",module.name));
    }
    if module.func {
        if header {
            // ヘッダーを作る
            let out_struct = format!(
                "export interface {}Result {{\n    outputs: boolean[];\n}}",
                module.name,
            );
            let out_func_h = format!(
                "export function {}({}): {}Result;",
                module.name,
                (0..module.inputs as usize).map(|i| format!("i{}: boolean",i)).collect::<Vec<String>>().join(", "),
                module.name,
            );
            let out_header = format!(
                "{}\n\n{}\n\n{}\n\n{}",
                "// Generated by Neknaj Circuit Game",
                format!(
                    "export const {}OutputsLen: number;",
                    module.name,
                ),
                out_struct,
                out_func_h,
            );
            Ok(out_header)
        }
        else {
            // 本体の関数を作る
            let out_struct = format!(
                "export interface {}Result {{\n    outputs: boolean[];\n}}",
                module.name,
            );
            let out_const = format!(
                "export const {}OutputsLen: number = {};",
                module.name,
                module.outputs.len(),
            );
            let out_func_head = format!(
                "export function {}({}): {}Result",
                module.name,
                (0..module.inputs as usize).map(|i| format!("b{}: boolean",i+module.gates_sequential.len())).collect::<Vec<String>>().join(", "),
                module.name,
            );
            let out_func_gates = module.gates_sequential.iter().enumerate().map(|(index,value)| format!("    const b{} = !( b{} || b{} );",index,value.0,value.1)).collect::<Vec<String>>().join("\n");
            let out_func_return = format!(
                "    return {{ outputs: [ {} ] }};",
                module.outputs.iter().map(|value| format!("b{}",value)).collect::<Vec<String>>().join(", "),
            );
            let out_func = format!(
                "{} {{\n{}\n{}\n}}",
                out_func_head,
                out_func_gates,
                out_func_return,
            );
            let out_code = format!(
                "{}\n\n{}\n\n{}\n\n{}",
                "// Generated by Neknaj Circuit Game",
                out_const,
                out_struct,
                out_func,
            );
            Ok(out_code)
        }
    }
    else {
        if header {
            // ヘッダーを作る
            let out_struct = format!(
                "export interface {}Result {{\n    outputs: boolean[];\n}}",
                module.name,
            );
            let out_func_h = format!(
                "export function {}({}): {}Result;",
                module.name,
                (0..module.inputs as usize).map(|i| format!("i{}: boolean",i)).collect::<Vec<String>>().join(", "),
                module.name,
            );
            let out_header = format!(
                "{}\n\n{}\n\n{}\n\n{}",
                "// Generated by Neknaj Circuit Game",
                format!(
                    "export const {}OutputsLen: number;",
                    module.name,
                ),
                out_struct,
                out_func_h,
            );
            Ok(out_header)
        }
        else {
            // 本体の関数を作る
            let out_func_gates = module.gates_sequential.iter().enumerate().map(|(index,value)| format!("        this.b[{}] = !( this.b[{}] || this.b[{}] );",index,value.0,value.1)).collect::<Vec<String>>().join("\n");
            let constructor_func = format!(
                "    constructor () {{\n{}\n    }}",
                format!("        this.b = new Array(0);"),
            );
            let next_func = format!(
                "    next(): this {{\n{}\n{}\n    }}",
                out_func_gates,
                format!("        return this;"),
            );
            let out_func_return = format!(
                "        return [ {} ];",
                module.outputs.iter().map(|value| format!("this.b[{}]",value)).collect::<Vec<String>>().join(", "),
            );
            let get_func = format!(
                "    get outputs(): boolean[] {{\n{}\n    }}",
                out_func_return,
            );
            let input_func = format!(
                "    inputs({}) {{\n{}\n    }}",
                (0..module.inputs as usize).map(|i| format!("i{}: boolean",i)).collect::<Vec<String>>().join(", "),
                (0..module.inputs as usize).map(|index| format!("        this.b[{}] = i{};",index+module.gates_sequential.len(),index)).collect::<Vec<String>>().join("\n"),
            );
            let out_code = format!(
                "{}\n\nclass {} {{\n{}\n{}\n{}\n{}\n{}\n{}\n}}",
                "// Generated by Neknaj Circuit Game",
                module.name,
                format!("    private b: boolean[];"),
                format!("    static outputsLen: number = {};",module.outputs.len()),
                constructor_func,
                input_func,
                next_func,
                get_func,
            );
            Ok(out_code)
        }
    }
}